import streamlit as st
from dotenv import load_dotenv, find_dotenv
import os

# Imports t·ª´ project c·ªßa b·∫°n
# ƒê·∫£m b·∫£o c√°c ƒë∆∞·ªùng d·∫´n n√†y ch√≠nh x√°c v√† c√°c module c√≥ th·ªÉ ƒë∆∞·ª£c import
try:
    from core.graph.codegen_graph import CodeGenGraph
    from core.graph.unittest_gen_graph import UnitTestWorkflow
    from core.agents.main import create_supervisor_agent, create_research_agent
    from core.database.vector_store import VectorStore
    from core.graph.utils.helper import get_model
except ImportError as e:
    st.error(f"L·ªói import module 'core': {e}. H√£y ƒë·∫£m b·∫£o r·∫±ng th∆∞ m·ª•c 'core' c·ªßa b·∫°n n·∫±m trong PYTHONPATH ho·∫∑c c√πng c·∫•p v·ªõi file app Streamlit n√†y.")
    st.stop() # NgƒÉn kh√¥ng cho app ch·∫°y ti·∫øp n·∫øu kh√¥ng import ƒë∆∞·ª£c

# --- T·∫£i c·∫•u h√¨nh v√† kh·ªüi t·∫°o c√°c th√†nh ph·∫ßn (ch·∫°y m·ªôt l·∫ßn) ---
@st.cache_resource # S·ª≠ d·ª•ng cache_resource ƒë·ªÉ tr√°nh kh·ªüi t·∫°o l·∫°i tr√™n m·ªói l·∫ßn t∆∞∆°ng t√°c
def initialize_components():
    """
    T·∫£i bi·∫øn m√¥i tr∆∞·ªùng v√† kh·ªüi t·∫°o t·∫•t c·∫£ c√°c th√†nh ph·∫ßn c·∫ßn thi·∫øt.
    """
    load_dotenv(find_dotenv())

    default_model_name = os.getenv("DEFAULT_MODEL")
    vectorstore_path = os.getenv("VECTORSTORE_PATH")
    vectorstore_collection = os.getenv("VECTORSTORE_COLLECTION")

    # Ki·ªÉm tra c√°c bi·∫øn m√¥i tr∆∞·ªùng thi·∫øt y·∫øu
    if not all([default_model_name, vectorstore_path, vectorstore_collection]):
        missing_vars = [var for var, val in [("DEFAULT_MODEL", default_model_name),
                                             ("VECTORSTORE_PATH", vectorstore_path),
                                             ("VECTORSTORE_COLLECTION", vectorstore_collection)] if not val]
        st.error(f"Thi·∫øu c√°c bi·∫øn m√¥i tr∆∞·ªùng sau: {', '.join(missing_vars)}. Vui l√≤ng ki·ªÉm tra file .env ho·∫∑c c√†i ƒë·∫∑t m√¥i tr∆∞·ªùng c·ªßa b·∫°n.")
        return None # Tr·∫£ v·ªÅ None n·∫øu thi·∫øu

    try:
        llm = get_model(model=default_model_name)

        vector_database = VectorStore(
            persistent_path=vectorstore_path,
            collection_name=vectorstore_collection
        )
        code_generator = CodeGenGraph(
            model=default_model_name, # Ho·∫∑c truy·ªÅn llm ƒë√£ kh·ªüi t·∫°o n·∫øu CodeGenGraph ch·∫•p nh·∫≠n
            retriever=vector_database.as_retriever()
        )
        unit_test_generator = UnitTestWorkflow() # Gi·∫£ s·ª≠ kh√¥ng c·∫ßn tham s·ªë ph·ª©c t·∫°p
        
        # ƒê·ªïi t√™n bi·∫øn ƒë·ªÉ tr√°nh xung ƒë·ªôt n·∫øu create_research_agent l√† h√†m
        research_agent_instance = create_research_agent( 
            model=llm
        )

        supervisor = create_supervisor_agent(
            llm=llm,
            agents=[
                code_generator.as_graph(),
                unit_test_generator.as_graph(),
                research_agent_instance # S·ª≠ d·ª•ng instance ƒë√£ kh·ªüi t·∫°o
            ],
            add_handoff_back_messages=True,
            output_mode="full_history" # R·∫•t quan tr·ªçng ƒë·ªÉ hi·ªÉn th·ªã l·ªãch s·ª≠
        )
        return supervisor, default_model_name # Ch·ªâ tr·∫£ v·ªÅ supervisor ho·∫∑c c√°c th√¥ng tin c·∫ßn hi·ªÉn th·ªã
    except Exception as e:
        st.error(f"L·ªói trong qu√° tr√¨nh kh·ªüi t·∫°o components: {e}")
        st.exception(e) # Hi·ªÉn th·ªã traceback chi ti·∫øt trong app
        return None

# --- Giao di·ªán ng∆∞·ªùi d√πng Streamlit ---
st.set_page_config(layout="wide", page_title="Supervisor Agent Demo")
st.title("üé¨ Demo H·ªá Th·ªëng Multi-Agent v·ªõi Supervisor")
st.markdown("·ª®ng d·ª•ng n√†y minh h·ªça c√°ch m·ªôt Supervisor Agent ƒëi·ªÅu ph·ªëi c√°c agent con (Code Generator, Unit Test Generator, Research Agent) ƒë·ªÉ th·ª±c hi·ªán y√™u c·∫ßu ph·ª©c t·∫°p.")

# Kh·ªüi t·∫°o c√°c components
init_result = initialize_components()

if init_result:
    supervisor_agent, model_name_loaded = init_result
    
    st.sidebar.header("Th√¥ng Tin C·∫•u H√¨nh")
    st.sidebar.success(f"‚úÖ Components ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o th√†nh c√¥ng!")
    st.sidebar.info(f"LLM Model ƒëang s·ª≠ d·ª•ng: `{model_name_loaded}`")
    # B·∫°n c√≥ th·ªÉ th√™m th√¥ng tin kh√°c ·ªü ƒë√¢y n·∫øu mu·ªën (v√≠ d·ª•: ƒë∆∞·ªùng d·∫´n VectorStore)

    st.markdown("---")
    st.header("üìù Nh·∫≠p Y√™u C·∫ßu C·ªßa B·∫°n")
    st.markdown("Supervisor agent s·∫Ω ph√¢n t√≠ch y√™u c·∫ßu n√†y v√† ·ªßy quy·ªÅn cho c√°c agent ph√π h·ª£p.")

    # Y√™u c·∫ßu m·∫∑c ƒë·ªãnh t·ª´ code c·ªßa b·∫°n
    default_request = """Please write a Python program that implements a simple command-line contact book. Create a unit Test for this program after the code is generated.

The program should support the following features:

Add Contact:
Prompt the user for a name and a phone number.
Store these as a new contact. Ensure a name cannot be added if it already exists (names are unique identifiers).

View Contact:
Prompt the user for a name.
If the contact exists, display their name and phone number.
If not found, inform the user.

Delete Contact:
Prompt the user for a name.
If the contact exists, remove it.
If not found, inform the user.

View All Contacts:
Display all stored contacts, showing both name and phone number for each.

Requirements & Constraints:
Use a dictionary to store the contacts, where the key is the contact's name (string) and the value is the phone number (string).
The program should loop, allowing the user to perform multiple actions until they choose an "exit" option.
Provide a simple menu for the user to choose an action (e.g., "1. Add", "2. View", "3. Delete", "4. View All", "5. Exit").
Handle basic input validation where appropriate (e.g., ensure the user enters a number for menu choices if that's how you structure it).
"""
    user_request = st.text_area("Nh·∫≠p y√™u c·∫ßu:", value=default_request, height=350,
                                help="M√¥ t·∫£ chi ti·∫øt t√°c v·ª• b·∫°n mu·ªën supervisor th·ª±c hi·ªán, v√≠ d·ª•: t·∫°o code, vi·∫øt unit test, nghi√™n c·ª©u...")

    if st.button("üöÄ Ch·∫°y Supervisor Agent", type="primary", use_container_width=True):
        if not user_request.strip():
            st.warning("‚ö†Ô∏è Vui l√≤ng nh·∫≠p y√™u c·∫ßu.")
        else:
            st.markdown("---")
            st.header("üîç K·∫øt Qu·∫£ Th·ª±c Thi & L·ªãch S·ª≠ T∆∞∆°ng T√°c")
            with st.spinner("Supervisor agent ƒëang x·ª≠ l√Ω y√™u c·∫ßu c·ªßa b·∫°n... Qu√° tr√¨nh n√†y c√≥ th·ªÉ m·∫•t m·ªôt ch√∫t th·ªùi gian. ‚è≥"):
                try:
                    # Input cho supervisor agent th∆∞·ªùng l√† m·ªôt dict v·ªõi key "messages"
                    input_payload = {"messages": [("user", user_request)]}
                    
                    # G·ªçi supervisor agent
                    results = supervisor_agent.invoke(input_payload)

                    # Hi·ªÉn th·ªã k·∫øt qu·∫£ - `output_mode="full_history"` s·∫Ω tr·∫£ v·ªÅ to√†n b·ªô l·ªãch s·ª≠ message
                    if isinstance(results, dict) and "messages" in results:
                        st.info(f"Ho√†n th√†nh! {len(results['messages'])} tin nh·∫Øn trong l·ªãch s·ª≠ t∆∞∆°ng t√°c.")
                        
                        for i, message in enumerate(results["messages"]):
                            msg_type = getattr(message, 'type', 'unknown_type')
                            msg_content = getattr(message, 'content', str(message))
                            msg_name = getattr(message, 'name', None)
                            additional_kwargs = getattr(message, 'additional_kwargs', {})
                            tool_calls = additional_kwargs.get('tool_calls', [])
                            function_call_details = additional_kwargs.get('function_call', None)

                            role_icon = "üë§" if msg_type.lower() == "human" or msg_name is None else \
                                        "ü§ñ" if msg_type.lower() == "ai" or msg_name else \
                                        "üõ†Ô∏è" if msg_type.lower() == "tool" else "üí¨"
                            
                            with st.expander(f"{role_icon} **Tin nh·∫Øn {i+1}:** `{msg_type.upper()}` {f'- Agent: `{msg_name}`' if msg_name else ''}", expanded= i == len(results["messages"]) -1 ): # M·ªü r·ªông tin nh·∫Øn cu·ªëi
                                st.markdown(f"**N·ªôi dung:**")
                                # N·∫øu n·ªôi dung l√† code Python, hi·ªÉn th·ªã d∆∞·ªõi d·∫°ng code block
                                if "python" in str(msg_content).lower() and ("def " in msg_content or "import " in msg_content or "class " in msg_content):
                                    # C·ªë g·∫Øng tr√≠ch xu·∫•t code n·∫øu n√≥ n·∫±m trong markdown backticks
                                    cleaned_content = msg_content
                                    if "```python" in msg_content:
                                        cleaned_content = msg_content.split("```python\n", 1)[-1].split("\n```", 1)[0]
                                    elif "```" in msg_content:
                                         cleaned_content = msg_content.split("```\n", 1)[-1].split("\n```", 1)[0]
                                    st.code(cleaned_content, language="python")
                                else:
                                    st.markdown(f"```text\n{msg_content}\n```" if isinstance(msg_content, str) and len(msg_content) > 80 else str(msg_content))

                                if tool_calls:
                                    st.markdown("**L·ªánh g·ªçi Tool (Tool Calls):**")
                                    for tc_idx, tool_call in enumerate(tool_calls):
                                        st.json(tool_call, expanded=False)
                                if function_call_details:
                                    st.markdown("**L·ªánh g·ªçi H√†m (Function Call):**")
                                    st.json(function_call_details, expanded=False)
                                if additional_kwargs and not tool_calls and not function_call_details:
                                    st.markdown("**Th√¥ng tin th√™m (Additional Kwargs):**")
                                    st.json(additional_kwargs, expanded=False)
                    else:
                        st.warning("K·∫øt qu·∫£ tr·∫£ v·ªÅ kh√¥ng c√≥ ƒë·ªãnh d·∫°ng l·ªãch s·ª≠ tin nh·∫Øn nh∆∞ mong ƒë·ª£i.")
                        st.json(results) # Hi·ªÉn th·ªã raw JSON n·∫øu kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng

                except Exception as e:
                    st.error(f"üö´ ƒê√£ x·∫£y ra l·ªói trong qu√° tr√¨nh th·ª±c thi:")
                    st.exception(e) # Hi·ªÉn th·ªã traceback ƒë·∫ßy ƒë·ªß
else:
    st.error("Kh√¥ng th·ªÉ kh·ªüi t·∫°o c√°c th√†nh ph·∫ßn. Vui l√≤ng ki·ªÉm tra log v√† c·∫•u h√¨nh.")

st.markdown("---")
st.sidebar.markdown("---")
st.sidebar.markdown("üßë‚Äçüíª **Th√¥ng tin th√™m:**")
st.sidebar.markdown("·ª®ng d·ª•ng n√†y s·ª≠ d·ª•ng Streamlit ƒë·ªÉ t·∫°o giao di·ªán v√† LangGraph ƒë·ªÉ x√¢y d·ª±ng h·ªá th·ªëng multi-agent. C√°c agent giao ti·∫øp v√† ƒë∆∞·ª£c ƒëi·ªÅu ph·ªëi b·ªüi m·ªôt Supervisor Agent trung t√¢m.")
st.sidebar.markdown("M√£ ngu·ªìn Streamlit n√†y ƒë∆∞·ª£c t·∫°o ƒë·ªÉ demo ƒëo·∫°n code Python ƒë∆∞·ª£c cung c·∫•p.")