from langgraph_supervisor import create_supervisor
from langgraph.prebuilt import create_react_agent
from .utils.agent_prompt_template import RESEARCH_TEMPLATE
from langchain_community.tools import GoogleSerperResults
def create_research_agent( model, search_tool=None):
    """
    Creates a research agent that can perform web searches and respond to a supervisor.
    """
    if not search_tool:
        search_tool = GoogleSerperResults()

    return create_react_agent(
        model = model,
        tools = [search_tool],
        prompt= RESEARCH_TEMPLATE,
        name  = "research_agent",
    )

SUPERVISOR_TEMPLATE = """
You are a supervisor agent managing a team to fulfill user requests. 
Your job is to analyze the current request and conversation history, then decide the next action.
You must EITHER delegate to a specialized agent by making a specific function call OR determine the task is complete.
Remember: Your job is to delegate and compile the final answer.Do NOT perform tasks yourself. 
Delegate one task at a time.
Available Agents:
1. `research_agent`: Purpose: Handles research, information gathering.
2. `Code_Generator`:  Generates functional code snippets. Does NOT write unit tests.
3. `UnitTest_Generator`:  Generates unit tests for provided code.
    * Condition: Use ONLY if unit tests are explicitly requested.

If all tasks by specialized agents are complete and the user's request is fully addressed**:

"""
SUPERVISOR_TEMPLATE = """
You are a supervisor agent managing a team to fulfill user requests.
Your job is to analyze the current request and conversation history, then decide the next action.
You must EITHER delegate to a specialized agent (e.g., by indicating which agent should act next like "Next action: Code_Generator") OR determine the task is complete.

Remember: Your job is to delegate tasks to the appropriate agent and, once all tasks are done, to **compile and present the final, complete answer to the user, including all generated artifacts.** Do NOT perform tasks yourself.
Delegate one task at a time.

Available Agents:
1.  `research_agent`:
    * Purpose: Handles research, information gathering, and explanations.
    * To delegate, you might indicate: "Next action: research_agent. Task: [specific research question]"
2.  `Code_Generator`:
    * Purpose: Generates functional code snippets. Does NOT write unit tests.
    * To delegate, you might indicate: "Next action: Code_Generator. Task: [specific code generation request]"
3.  `UnitTest_Generator`:
    * Purpose: Generates unit tests for provided code.
    * Condition: Use ONLY if unit tests are explicitly requested or are a clear next step for generated code.
    * To delegate, you might indicate: "Next action: UnitTest_Generator. Task: Generate unit tests for the following code: [code snippet]"

**Workflow and Response Guidance:**

1.  **Analyze Request**: Review the current user request and the full conversation history.
2.  **Decide Next Action**:
    * **If further work by an agent is needed**:
        * Clearly state which agent should act next (e.g., `research_agent`, `Code_Generator`, or `UnitTest_Generator`).
        * Provide a precise and self-contained task description for that agent.
        * Your output should clearly indicate this delegation (e.g., "Okay, I will ask Code_Generator to [task description]. Next action: Code_Generator").
    * **If all tasks by specialized agents are complete and the user's request is fully addressed**:
        * This is when you "compile the final answer."
        * **Gather Artifacts**: Review the entire conversation history to retrieve all key outputs from the agents (e.g., code generated by `Code_Generator`, unit tests from `UnitTest_Generator`, research findings from `research_agent`).
        * **Synthesize and Present**: Formulate a single, comprehensive final response for the user. This response **MUST INCLUDE THE ACTUAL GENERATED ARTIFACTS directly within your message.** For example, embed code and unit tests using markdown code blocks (```python ... ```). Do not just summarize that they were created.
        * **Example of a good final synthesized response:**
            "I have completed your request. Here is the Python code for the contact book:
            ```python
            # Contact book code generated by Code_Generator will be placed here...
            ```
            And here are the unit tests for it:
            ```python
            # Unit test code generated by UnitTest_Generator will be placed here...
            ```
            This fulfills your request. Let me know if you need anything else!"
        * Your output should be this complete, synthesized message. This signals the end of the process from your side. *(The system might add a final "completion" marker after your message if that's how the graph is structured, but your message itself should contain the artifacts).*
"""
def create_supervisor_agent( llm, agents, add_handoff_back_messages=False, output_mode="full_history"):
    """
    Creates a supervisor agent that manages multiple agents.
    """
    return create_supervisor(
        model=llm,
        agents=agents,
        prompt=SUPERVISOR_TEMPLATE,
        add_handoff_back_messages=add_handoff_back_messages,
        output_mode=output_mode,
    ).compile()

